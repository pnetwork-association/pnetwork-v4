const { expect } = require('chai')
const { Blockchain, expectToThrow, mintTokens } = require('@eosnetwork/vert')
const { deploy } = require('./utils/deploy')
const { Asset } = require('@wharfkit/antelope')
const R = require('ramda')
const {
  active,
  precision,
  getAccountCodeRaw,
  getSymbolCodeRaw,
  getSingletonInstance,
} = require('./utils/eos-ext')
const { no0x, hexStringToBytes } = require('./utils/bytes-utils')
const { sum } = require('./utils/wharfkit-ext')
const { getAccountsBalances } = require('./utils/get-token-balance')
const errors = require('./utils/errors')

const ethers = require('ethers')
const {
  evmOperationSamples,
  evmTopicZero,
  evmAdapter,
} = require('./samples/evm-operations')
const { evmMetadataSamples, teePubKey } = require('./samples/evm-metadata')
const { adjustPrecision, fromWei } = require('./utils/precision-utils')

const attestation = 'deadbeef'

describe('Adapter EVM -> EOS testing', () => {
  const evmTokenSymbol = 'TST'
  const maxSupply = '500000000'
  const evmPrecision = 18
  const evmXERC20Precision = 8

  const TABLE_STORAGE = 'storage'

  // infos of the underlying token
  const evmUnderlyingToken = {
    symbol: evmTokenSymbol,
    precision: evmPrecision, // this should be the actual precision of the underlying token
    account: '',
    maxSupply: `${adjustPrecision(maxSupply, evmXERC20Precision)} ${evmTokenSymbol}`, // use evmXERC20Precision to avoid overflow
    bytes: evmOperationSamples.pegin.token,
  }

  const evmXERC20 = {
    symbol: `X${evmTokenSymbol}`,
    precision: evmXERC20Precision, // different from the underlying token - only uint64 is supported by Asset type
    account: `x${evmTokenSymbol.toLowerCase()}.token`,
    maxSupply: `${adjustPrecision(maxSupply, evmXERC20Precision)} X${evmTokenSymbol}`,
    minFee: `${adjustPrecision('0.0018', evmXERC20Precision)} X${evmTokenSymbol}`,
    contract: null,
  }

  const wrongToken = {
    symbol: 'WRG',
    account: 'wrg.token',
    maxSupply: `${maxSupply} WRG`,
    bytes: no0x(
      ethers.zeroPadValue(
        ethers.toBeHex(getSymbolCodeRaw('0.0000 WRG').toString()),
        32,
      ),
    ),
    contract: null,
  }

  const lockbox = {
    account: 'lockbox',
    contract: null,
  }

  const adapter = {
    account: 'adapter',
    contract: null,
  }

  const notInitAdapter = {
    account: 'adapter2',
    contract: null,
  }

  const receiver = {
    account: 'receiver',
    contract: null,
  }

  const blockchain = new Blockchain()

  const user = 'user'
  const evil = 'evil'
  const issuer = 'issuer'
  const bridge = 'bridge'
  const recipient = 'eosrecipient'
  const feemanager = 'feemanager'

  before(async () => {
    blockchain.createAccounts(user, evil, issuer, bridge, recipient, feemanager)
    lockbox.contract = deploy(
      blockchain,
      lockbox.account,
      'contracts/build/lockbox',
    )
    evmXERC20.contract = deploy(
      blockchain,
      evmXERC20.account,
      'contracts/build/xerc20.token',
    )
    adapter.contract = deploy(
      blockchain,
      adapter.account,
      'contracts/build/adapter',
    )
    notInitAdapter.contract = deploy(
      blockchain,
      notInitAdapter.account,
      'contracts/build/adapter',
    )
    receiver.contract = deploy(
      blockchain,
      receiver.account,
      'contracts/build/test.receiver',
    )
  })

  describe('adapter::create', () => {
    it('Should throw if called by not authorized account', async () => {
      const action = adapter.contract.actions
        .create([
          evmXERC20.account,
          precision(evmXERC20.precision, evmXERC20.symbol),
          evmUnderlyingToken.account,
          precision(evmUnderlyingToken.precision, evmUnderlyingToken.symbol),
          evmUnderlyingToken.bytes,
          evmXERC20.minFee,
        ])
        .send(active(evil))

      await expectToThrow(action, errors.AUTH_MISSING(adapter.account))
    })

    // This test requires a try catch because expectToThrow do not work with error generated by passing a wrong type to an action
    it('Should throw if tokenByte size is not 32', async () => {
      const wrongBytes = 'aa'
      try {
        await adapter.contract.actions
          .create([
            evmXERC20.account,
            precision(evmXERC20.precision, evmXERC20.symbol),
            evmUnderlyingToken.account,
            precision(evmUnderlyingToken.precision, evmUnderlyingToken.symbol),
            wrongBytes,
            evmXERC20.minFee,
          ])
          .send(active(adapter.account))

        fail()
      } catch (_err) {
        expect(_err.underlyingError.toString()).to.be.equal(
          `Error: Checksum size mismatch, expected 32 bytes got ${wrongBytes.length / 2}`,
        )
      }
    })

    it('Should throw if xERC20 account does not exist', async () => {
      const action = adapter.contract.actions
        .create([
          'undeployed',
          precision(evmXERC20.precision, evmXERC20.symbol),
          evmUnderlyingToken.account,
          precision(evmUnderlyingToken.precision, evmUnderlyingToken.symbol),
          evmUnderlyingToken.bytes,
          evmXERC20.minFee,
        ])
        .send(active(adapter.account))

      await expectToThrow(action, 'eosio_assert: xERC20 account does not exist')
    })

    it('Should throw if minFee precision does not match', async () => {
      const action = adapter.contract.actions
        .create([
          evmXERC20.account,
          precision(evmXERC20.precision, evmXERC20.symbol),
          evmUnderlyingToken.account,
          precision(evmUnderlyingToken.precision, evmUnderlyingToken.symbol),
          evmUnderlyingToken.bytes,
          '12, XTST',
        ])
        .send(active(adapter.account))

      await expectToThrow(action, errors.INVALID_MINFEE_SYMBOL)
    })

    it('Should throw if minFee symbol does not match', async () => {
      const action = adapter.contract.actions
        .create([
          evmXERC20.account,
          precision(evmXERC20.precision, evmXERC20.symbol),
          evmUnderlyingToken.account,
          precision(evmUnderlyingToken.precision, evmUnderlyingToken.symbol),
          evmUnderlyingToken.bytes,
          `${adjustPrecision('0.0018', evmXERC20Precision)} XYYY`,
        ])
        .send(active(adapter.account))

      await expectToThrow(action, errors.INVALID_MINFEE_SYMBOL)
    })

    it('Should throw if xERC20 symbol is not found on xERC20 account', async () => {
      const unknownSymbol = 'XXYY'
      const action = adapter.contract.actions
        .create([
          evmXERC20.account,
          precision(evmXERC20.precision, unknownSymbol),
          evmUnderlyingToken.account,
          precision(evmUnderlyingToken.precision, evmUnderlyingToken.symbol),
          evmUnderlyingToken.bytes,
          `${adjustPrecision('0.0018', evmXERC20Precision)} ${unknownSymbol}`,
        ])
        .send(active(adapter.account))

      await expectToThrow(action, errors.WRONG_SYM_PRECISION)
    })

    it('Should throw if symbol precision is not correct', async () => {
      const action = adapter.contract.actions
        .create([
          evmXERC20.account,
          precision(13, evmXERC20.symbol),
          evmUnderlyingToken.account,
          precision(evmUnderlyingToken.precision, evmUnderlyingToken.symbol),
          evmUnderlyingToken.bytes,
          `${adjustPrecision('0.0018', 13)} X${evmTokenSymbol}`,
        ])
        .send(active(adapter.account))

      await expectToThrow(action, errors.WRONG_SYM_PRECISION)
    })

    //TODO deploy local token
    // it('Should throw if token is local and token symbol is not found on xERC20 account', async () => {
    //   const action = adapter.contract.actions
    //     .create([
    //       evmXERC20.account,
    //       precision(evmXERC20.precision, evmXERC20.symbol),
    //       evmUnderlyingToken.account,
    //       precision(evmUnderlyingToken.precision, 'XYYY'),
    //       evmUnderlyingToken.bytes,
    //       evmXERC20.minFee,
    //     ])
    //     .send(active(adapter.account))

    //   await expectToThrow(action, 'eosio_assert: invalid minimum fee symbol')
    // })
    // it('Should throw if token is local and xERC20 precision do not match it', async () => {
    //   const action = adapter.contract.actions
    //     .create([
    //       evmXERC20.account,
    //       precision(evmXERC20.precision, evmXERC20.symbol),
    //       'token',
    //       precision(evmUnderlyingToken.precision, evmUnderlyingToken.symbol),
    //       evmUnderlyingToken.bytes,
    //       evmXERC20.minFee,
    //     ])
    //     .send(active(adapter.account))

    //   await expectToThrow(action, 'eosio_assert: invalid minimum fee symbol')
    // })
    // it('Should throw if token is local and token account does not exist', async () => {
    //   const action = adapter.contract.actions
    //     .create([
    //       'undeployed',
    //       precision(evmXERC20.precision, evmXERC20.symbol),
    //       evmUnderlyingToken.account,
    //       precision(evmUnderlyingToken.precision, evmUnderlyingToken.symbol),
    //       evmUnderlyingToken.bytes,
    //       evmXERC20.minFee,
    //     ])
    //     .send(active(adapter.account))

    //   await expectToThrow(action, 'eosio_assert: xERC20 account does not exist')
    // })

    const setup = async () => {
      await evmXERC20.contract.actions
        .create([issuer, evmXERC20.maxSupply])
        .send(active(evmXERC20.account))

      const mintingLimit = `${adjustPrecision('1000', evmXERC20Precision)} ${evmXERC20.symbol}`
      const burningLimit = `${adjustPrecision('600', evmXERC20Precision)} ${evmXERC20.symbol}`

      await evmXERC20.contract.actions
        .setlimits([adapter.account, mintingLimit, burningLimit])
        .send(active(evmXERC20.account))
    }

    it('Should create the pair successfully', async () => {
      await setup()

      await adapter.contract.actions
        .create([
          evmXERC20.account,
          precision(evmXERC20.precision, evmXERC20.symbol),
          evmUnderlyingToken.account,
          precision(evmUnderlyingToken.precision, evmUnderlyingToken.symbol),
          evmUnderlyingToken.bytes,
          evmXERC20.minFee,
        ])
        .send(active(adapter.account))

      const row = getSingletonInstance(adapter.contract, 'regadapter')
      const storage = getSingletonInstance(adapter.contract, TABLE_STORAGE)
      const tee = getSingletonInstance(adapter.contract, 'tee')
      const mappingsRow = adapter.contract.tables
        .mappings(getAccountCodeRaw(adapter.account))
        .getTableRows()

      expect(row).to.be.deep.equal({
        token: '',
        token_symbol: precision(18, 'XXX'),
        token_bytes: evmUnderlyingToken.bytes,
        xerc20: evmXERC20.account,
        xerc20_symbol: precision(evmXERC20.precision, evmXERC20.symbol),
        min_fee: evmXERC20.minFee,
      })
      expect(storage).be.deep.equal({
        nonce: 0,
        feesmanager: '',
      })
      expect(tee).to.be.undefined
      expect(mappingsRow).to.be.deep.equal([])
    })

    it('Should throw if already created', async () => {
      const action = adapter.contract.actions
        .create([
          'xerc20.2',
          precision(6, 'XERC'),
          'local',
          precision(6, 'XXX'),
          evmUnderlyingToken.bytes,
          evmXERC20.minFee,
        ])
        .send(active(adapter.account))

      await expectToThrow(action, 'eosio_assert: adapter already initialized')
    })
  })

  describe('adapter::setfeemanagr', () => {
    it('Should throw if called by not authorized account', async () => {
      const action = adapter.contract.actions
        .setfeemanagr([feemanager])
        .send(active(evil))

      await expectToThrow(action, errors.AUTH_MISSING(adapter.account))
    })

    it('Should throw if adapter is not initialized', async () => {
      const action = notInitAdapter.contract.actions
        .setfeemanagr([feemanager])
        .send(active(notInitAdapter.account))

      await expectToThrow(action, errors.NOT_INITIALIZED)
    })

    it('Should set the feemanager correctly', async () => {
      await adapter.contract.actions
        .setfeemanagr([user])
        .send(active(adapter.account))

      const storage = getSingletonInstance(adapter.contract, TABLE_STORAGE)

      expect(storage).be.deep.equal({
        nonce: 0,
        feesmanager: user,
      })
    })

    it('Should update the feemanager correctly', async () => {
      await adapter.contract.actions
        .setfeemanagr([feemanager])
        .send(active(adapter.account))

      const storage = getSingletonInstance(adapter.contract, TABLE_STORAGE)

      expect(storage).be.deep.equal({
        nonce: 0,
        feesmanager: feemanager,
      })
    })
  })

  describe('adapter::settee', () => {
    it('Should throw if called by not authorized account', async () => {
      const action = adapter.contract.actions
        .settee([teePubKey, attestation])
        .send(active(evil))

      await expectToThrow(action, errors.AUTH_MISSING(adapter.account))
    })

    it('Should set the tee pubKey and attestation correctly', async () => {
      await adapter.contract.actions
        .settee([teePubKey, attestation])
        .send(active(adapter.account))

      const tee = getSingletonInstance(adapter.contract, 'tee')

      expect(tee.key).to.be.equal(teePubKey.toString())
      expect(tee.attestation).to.be.equal(attestation)
    })
  })

  describe('adapter::setorigin', () => {
    it('Should throw if called by not authorized account', async () => {
      const originChainId = evmOperationSamples.pegin.originChainId
      const action = adapter.contract.actions
        .setorigin([
          hexStringToBytes(originChainId),
          hexStringToBytes(evmAdapter),
          hexStringToBytes(evmTopicZero),
        ])
        .send(active(evil))

      await expectToThrow(action, errors.AUTH_MISSING(adapter.account))
    })

    it('Should throw if emitter is not 32 bytes', async () => {
      const originChainId = evmOperationSamples.pegin.originChainId
      const wrong = '0xC0FFEE'
      const action = adapter.contract.actions
        .setorigin([
          hexStringToBytes(originChainId),
          hexStringToBytes(wrong),
          hexStringToBytes(evmTopicZero),
        ])
        .send(active(adapter.account))

      await expectToThrow(action, errors.EXPECTED_32_BYTES('emitter'))
    })

    it('Should throw if topic zero is not 32 bytes', async () => {
      const originChainId = evmOperationSamples.pegin.originChainId
      const wrong = '0xC0FFEE'
      const action = adapter.contract.actions
        .setorigin([
          hexStringToBytes(originChainId),
          hexStringToBytes(evmAdapter),
          hexStringToBytes(wrong),
        ])
        .send(active(adapter.account))

      await expectToThrow(action, errors.EXPECTED_32_BYTES('topic zero'))
    })

    it('Should throw if origin chain id is not 32 bytes', async () => {
      const wrong = 1
      const action = adapter.contract.actions
        .setorigin([
          wrong,
          hexStringToBytes(evmAdapter),
          hexStringToBytes(evmTopicZero),
        ])
        .send(active(adapter.account))

      await expectToThrow(action, errors.EXPECTED_32_BYTES('chain_id'))
    })

    it('Should set the origin details correctly', async () => {
      const originChainId = evmOperationSamples.pegin.originChainId
      const anAddress = no0x(
        ethers.zeroPadValue('0xe396757ec7e6ac7c8e5abe7285dde47b98f22db8', 32),
      )
      await adapter.contract.actions
        .setorigin([
          hexStringToBytes(originChainId),
          hexStringToBytes(anAddress),
          hexStringToBytes(evmTopicZero),
        ])
        .send(active(adapter.account))

      const row = adapter.contract.tables
        .mappings(getAccountCodeRaw(adapter.account))
        .getTableRow(ethers.stripZerosLeft(`0x${originChainId}`))

      expect(row.chain_id).to.be.equal(originChainId)
      expect(row.emitter).to.be.equal(anAddress)
      expect(row.topic_zero).to.be.equal(evmTopicZero)
    })

    it('Should update the origin details correctly', async () => {
      const originChainId = evmOperationSamples.pegin.originChainId
      await adapter.contract.actions
        .setorigin([
          hexStringToBytes(originChainId),
          hexStringToBytes(evmAdapter),
          hexStringToBytes(evmTopicZero),
        ])
        .send(active(adapter.account))

      const emitterRow = adapter.contract.tables
        .mappings(getAccountCodeRaw(adapter.account))
        .getTableRow(ethers.stripZerosLeft(`0x${originChainId}`))

      expect(emitterRow.chain_id).to.be.equal(originChainId)
      expect(emitterRow.emitter).to.be.equal(evmAdapter)
      expect(emitterRow.topic_zero).to.be.equal(evmTopicZero)
    })
  })

  describe('adapter::swap', () => {
    it('Should swap correctly', async () => {
      // TODO
    })
  })

  describe('adapter::settle', () => {
    const createOperationAsset = amount =>
      Asset.from(
        amount / 10 ** evmPrecision,
        precision(evmXERC20.precision, evmXERC20.symbol),
      )

    it('Should reject if adapter and token do not match', async () => {
      const operation = evmOperationSamples.pegin
      const metadata = evmMetadataSamples.pegin

      const action = adapter.contract.actions
        .settle([user, { ...operation, token: wrongToken.bytes }, metadata])
        .send(active(user))

      await expectToThrow(action, errors.INVALID_TOKEN)
    })

    it('Should settle the operation properly', async () => {
      const operation = evmOperationSamples.pegin
      const metadata = evmMetadataSamples.pegin

      const before = getAccountsBalances(
        [user, recipient, adapter.account, feemanager],
        [evmXERC20],
      )

      await adapter.contract.actions
        .settle([user, operation, metadata])
        .send(active(user))

      const after = getAccountsBalances(
        [user, recipient, adapter.account, feemanager],
        [evmXERC20],
      )

      const operationAsset = createOperationAsset(operation.amount)
      expect(after[recipient][evmXERC20.symbol]).to.be.equal(
        operationAsset.toString(),
      )

      expect(after[adapter.account][evmXERC20.symbol]).to.be.equal(
        `0.0000 ${evmXERC20.symbol}`,
      )

      expect(before[feemanager][evmXERC20.symbol]).to.be.equal(
        after[feemanager][evmXERC20.symbol],
      )
    })

    it('Should settle the operation properly and send userdata', async () => {
      const operation = evmOperationSamples.peginWithUserData
      const metadata = evmMetadataSamples.peginWithUserData

      const before = getAccountsBalances(
        [user, recipient, adapter.account],
        [evmXERC20],
      )
      const beforeAsset = Asset.from(before[recipient][evmXERC20.symbol])

      await adapter.contract.actions
        .settle([user, operation, metadata])
        .send(active(user))

      const after = getAccountsBalances(
        [user, recipient, adapter.account],
        [evmXERC20],
      )

      const operationAsset = createOperationAsset(operation.amount)
      expect(after[recipient][evmXERC20.symbol]).to.equal(
        sum(operationAsset, beforeAsset).toString(),
      )

      expect(after[adapter.account][evmXERC20.symbol]).to.be.equal(
        `0.0000 ${evmXERC20.symbol}`,
      )
    })

    it('Should truncate the passed amount to the set precision', async () => {
      const operation = evmOperationSamples.peginLargePrecision
      const metadata = evmMetadataSamples.peginLargePrecision

      const before = getAccountsBalances(
        [user, recipient, adapter.account],
        [evmXERC20],
      )
      const beforeAsset = Asset.from(before[recipient][evmXERC20.symbol])

      await adapter.contract.actions
        .settle([user, operation, metadata])
        .send(active(user))

      console.log(adapter.contract.bc.console)

      const after = getAccountsBalances(
        [user, recipient, adapter.account],
        [evmXERC20],
      )

      const operationAsset = createOperationAsset(operation.amount)
      const adjAmount = adjustPrecision(
        operationAsset.toString(),
        evmXERC20Precision,
      )
      const adjOperationAmount = Asset.from(`${adjAmount} ${evmXERC20.symbol}`)
      expect(after[recipient][evmXERC20.symbol]).to.equal(
        sum(adjOperationAmount, beforeAsset).toString(),
      )

      expect(after[adapter.account][evmXERC20.symbol]).to.be.equal(
        `0.0000 ${evmXERC20.symbol}`,
      )
    })
  })
})
